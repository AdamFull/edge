#pragma once

namespace edge::gfx {
	enum QueueCapabilityFlag {
		EDGE_GFX_QUEUE_CAPABILITY_NONE				= 0,
		EDGE_GFX_QUEUE_CAPABILITY_GRAPHICS			= 0x01,	// Graphics operations
		EDGE_GFX_QUEUE_CAPABILITY_COMPUTE			= 0x02,	// Compute shader dispatch
		EDGE_GFX_QUEUE_CAPABILITY_TRANSFER			= 0x04,	// Transfer/copy operations (implicit in Graphics/Compute)
		EDGE_GFX_QUEUE_CAPABILITY_PRESENT			= 0x08,	// Surface presentation support
		EDGE_GFX_QUEUE_CAPABILITY_SPARSE_BINDING	= 0x10,	// Sparse memory binding
		EDGE_GFX_QUEUE_CAPABILITY_PROTECTED			= 0x20,	// Protected memory operations
		EDGE_GFX_QUEUE_CAPABILITY_VIDEO_DECODE		= 0x40,	// Video decode operations
		EDGE_GFX_QUEUE_CAPABILITY_VIDEO_ENCODE		= 0x80,	// Video encode operations
		EDGE_GFX_QUEUE_CAPABILITY_OPTICAL_FLOW		= 0x40,	// NVIDIA optical flow
	};

	using QueueCapabilityFlags = uint16_t;

	namespace QueuePresets {
		// Universal graphics queue (Graphics + Compute + Transfer)
		static constexpr QueueCapabilityFlags kGraphics =
			EDGE_GFX_QUEUE_CAPABILITY_GRAPHICS |
			EDGE_GFX_QUEUE_CAPABILITY_COMPUTE |
			EDGE_GFX_QUEUE_CAPABILITY_TRANSFER;

		// Async compute queue (Compute + Transfer, no Graphics)
		static constexpr QueueCapabilityFlags kAsyncCompute =
			EDGE_GFX_QUEUE_CAPABILITY_COMPUTE |
			EDGE_GFX_QUEUE_CAPABILITY_TRANSFER;

		// Dedicated transfer queue (Transfer only, optimal for DMA)
		static constexpr QueueCapabilityFlags kDedicatedTransfer =
			EDGE_GFX_QUEUE_CAPABILITY_TRANSFER;

		// Graphics with present support
		static constexpr QueueCapabilityFlags kPresentGraphics =
			EDGE_GFX_QUEUE_CAPABILITY_GRAPHICS |
			EDGE_GFX_QUEUE_CAPABILITY_COMPUTE |
			EDGE_GFX_QUEUE_CAPABILITY_TRANSFER |
			EDGE_GFX_QUEUE_CAPABILITY_PRESENT;

		// Compute async with present support
		static constexpr QueueCapabilityFlags kPresentCompute =
			EDGE_GFX_QUEUE_CAPABILITY_COMPUTE |
			EDGE_GFX_QUEUE_CAPABILITY_TRANSFER |
			EDGE_GFX_QUEUE_CAPABILITY_PRESENT;
	}

	enum QueueSelectionStrategy {
		EDGE_GFX_QUEUE_SELECTION_STRATEGY_EXACT,				// Must match exactly the requested capabilities
		EDGE_GFX_QUEUE_SELECTION_STRATEGY_MINIMAL,				// Must have at least these capabilities
		EDGE_GFX_QUEUE_SELECTION_STRATEGY_PREFER_DEDICATED,		// Prefer queues with only requested capabilities
		EDGE_GFX_QUEUE_SELECTION_STRATEGY_PREFER_SHARED			// Prefer queues with additional capabilities
	};

	enum BufferFlag {
		EDGE_GFX_BUFFER_FLAG_NONE = 0,
		EDGE_GFX_BUFFER_FLAG_READBACK = 0x01,
		EDGE_GFX_BUFFER_FLAG_STAGING = 0x02,
		EDGE_GFX_BUFFER_FLAG_DYNAMIC = 0x04,
		EDGE_GFX_BUFFER_FLAG_VERTEX = 0x08,
		EDGE_GFX_BUFFER_FLAG_INDEX = 0x10,
		EDGE_GFX_BUFFER_FLAG_UNIFORM = 0x20,
		EDGE_GFX_BUFFER_FLAG_STORAGE = 0x40,
		EDGE_GFX_BUFFER_FLAG_INDIRECT = 0x80,
		EDGE_GFX_BUFFER_FLAG_ACCELERATION_BUILD = 0x100,
		EDGE_GFX_BUFFER_FLAG_ACCELERATION_STORE = 0x200,
		EDGE_GFX_BUFFER_FLAG_SHADER_BINDING_TABLE = 0x400,
	};

	using BufferFlags = uint16_t;

	static constexpr BufferFlags kReadbackBuffer{ EDGE_GFX_BUFFER_FLAG_READBACK };
	static constexpr BufferFlags kStagingBuffer{ EDGE_GFX_BUFFER_FLAG_STAGING };
	static constexpr BufferFlags kVertexBuffer{ EDGE_GFX_BUFFER_FLAG_VERTEX };
	static constexpr BufferFlags kDynamicVertexBuffer{ EDGE_GFX_BUFFER_FLAG_VERTEX | EDGE_GFX_BUFFER_FLAG_DYNAMIC };
	static constexpr BufferFlags kIndexBuffer{ EDGE_GFX_BUFFER_FLAG_INDEX };
	static constexpr BufferFlags kDynamicIndexBuffer{ EDGE_GFX_BUFFER_FLAG_INDEX | EDGE_GFX_BUFFER_FLAG_DYNAMIC };
	static constexpr BufferFlags kUniformBuffer{ EDGE_GFX_BUFFER_FLAG_UNIFORM };
	static constexpr BufferFlags kDynamicUniformBuffer{ EDGE_GFX_BUFFER_FLAG_UNIFORM | EDGE_GFX_BUFFER_FLAG_DYNAMIC };
	static constexpr BufferFlags kStorageBuffer{ EDGE_GFX_BUFFER_FLAG_STORAGE };
	static constexpr BufferFlags kDynamicStorageBuffer{ EDGE_GFX_BUFFER_FLAG_STORAGE | EDGE_GFX_BUFFER_FLAG_DYNAMIC };
	static constexpr BufferFlags kIndirectBuffer{ EDGE_GFX_BUFFER_FLAG_INDIRECT };
	static constexpr BufferFlags kDynamicIndirectBuffer{ EDGE_GFX_BUFFER_FLAG_INDIRECT | EDGE_GFX_BUFFER_FLAG_DYNAMIC };

	enum ImageFlag {
		EDGE_GFX_IMAGE_FLAG_NONE = 0,
		EDGE_GFX_IMAGE_FLAG_SAMPLE = 0x01,
		EDGE_GFX_IMAGE_FLAG_COPY_SOURCE = 0x02,
		EDGE_GFX_IMAGE_FLAG_COPY_TARGET = 0x04,
		EDGE_GFX_IMAGE_FLAG_COPY_STORAGE = 0x08,
		EDGE_GFX_IMAGE_FLAG_WRITE_COLOR = 0x10,
	};
	using ImageFlags = uint16_t;

	enum ResourceStateFlag {
		EDGE_GFX_RESOURCE_STATE_UNDEFINED = 0,

		EDGE_GFX_RESOURCE_STATE_VERTEX_READ = 0x01,
		EDGE_GFX_RESOURCE_STATE_INDEX_READ = 0x02,

		EDGE_GFX_RESOURCE_STATE_RENDER_TARGET = 0x04,
		EDGE_GFX_RESOURCE_STATE_UNORDERED_ACCESS = 0x08,

		EDGE_GFX_RESOURCE_STATE_DEPTH_WRITE = 0x10,
		EDGE_GFX_RESOURCE_STATE_DEPTH_READ = 0x20,
		EDGE_GFX_RESOURCE_STATE_STENCIL_WRITE = 0x40,
		EDGE_GFX_RESOURCE_STATE_STENCIL_READ = 0x80,

		EDGE_GFX_RESOURCE_STATE_DEPTH_STENCIL_WRITE = EDGE_GFX_RESOURCE_STATE_DEPTH_WRITE | EDGE_GFX_RESOURCE_STATE_STENCIL_WRITE,
		EDGE_GFX_RESOURCE_STATE_DEPTH_STENCIL_READ = EDGE_GFX_RESOURCE_STATE_DEPTH_READ | EDGE_GFX_RESOURCE_STATE_STENCIL_READ,

		EDGE_GFX_RESOURCE_STATE_NON_GRAPHICS_SHADER = 0x100,
		EDGE_GFX_RESOURCE_STATE_GRAPHICS_SHADER = 0x200,
		EDGE_GFX_RESOURCE_STATE_SHADER_RESOURCE = EDGE_GFX_RESOURCE_STATE_NON_GRAPHICS_SHADER | EDGE_GFX_RESOURCE_STATE_GRAPHICS_SHADER,

		EDGE_GFX_RESOURCE_STATE_INDIRECT_ARGUMENT = 0x400,
		EDGE_GFX_RESOURCE_STATE_COPY_DST = 0x800,
		EDGE_GFX_RESOURCE_STATE_COPY_SRC = 0x1000,
		EDGE_GFX_RESOURCE_STATE_PRESENT = 0x2000,

		EDGE_GFX_RESOURCE_STATE_ACCELERATION_READ = 0x4000,
		EDGE_GFX_RESOURCE_STATE_ACCELERATION_WRITE = 0x8000,
	};

	using ResourceStateFlags = uint32_t;
}